options {
	LOOKAHEAD = 1;
}

PARSER_BEGIN(YalToJvm)

import java.io.FileNotFoundException;
import java.io.FileInputStream;
import java.io.File;

public class YalToJvm {

	private static Module module;

	public static void main(String[] args) throws ParseException, FileNotFoundException {
		File file = new File(args[0]);
		FileInputStream fs = new FileInputStream(file);
		YalToJvm parser = new YalToJvm(fs);
		SimpleNode root = parser.Module();
		root.dump("");
	}
}

PARSER_END(YalToJvm)

<DEFAULT> SKIP: {
	" "
	| "\t"
	| "\n"
	| "\r"
	| <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
	| <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}

<DEFAULT> TOKEN: {
	<RELA_OP: ">" | "<" | "<=" | ">=" | "==" | "!=">
	| <ADDSUB_OP: "+" | "-">
	| <ARITH_OP: "*" | "/" | "<<" | ">>" | ">>>">
	| <BITWISE_OP: "&" | "|" | "^">
	| <NOT_OP: "!">
	| <WHILE: "while">
	| <IF: "if">
	| <ELSE: "else">
	| <ASSIGN: "=">
	| <ASPA: "\"">
	| <LPAR: "(">
	| <RPAR: ")">
	| <VIRG: ",">
	| <PVIRG: ";">
	| <LCHAVETA: "{">
	| <RCHAVETA: "}">
	| <FUNCTION: "function">
	| <MODULE: "module">
	| <SIZE: "size">
}

<DEFAULT> TOKEN: {
	<INTEGER: (<DIGIT>)+>
	| <ID: <LETTER> (<LETTER> | <DIGIT>)*>
	| <#LETTER: ["$","A"-"Z","_","a"-"z"]>
	| <#DIGIT: ["0"-"9"]>
	| <STRING: <ASPA> (["a"-"z","A"-"Z","0"-"9",":"," ","="])+ <ASPA>>
}

SimpleNode Module() #Module: {Token moduleID;}
{
	<MODULE> moduleID=<ID> {
		module = new Module(moduleID.image);
		//System.out.println("Module: " + module.getModuleID());
	} <LCHAVETA> (Declaration())* (Function())* <RCHAVETA> { module.printSymbolTables();return jjtThis;  }
}

void Declaration() #Declaration: { String id; int size; Token integer; Token sign = null; }
{
	(LOOKAHEAD(2)
	id=ArrayElement() {
		module.addGlobalVariable(new Array(id,1));
	}
	| id=ScalarElement() {
		module.addGlobalVariable(new Variable(id));
	} )
	(<ASSIGN> (("[" size=ArraySize() "]") {

	}
	| (sign=<ADDSUB_OP>)? integer=<INTEGER> {
		Variable s = module.getGlobalVariable(id);
		if(s instanceof Variable){
			s = new Scalar(id,Integer.parseInt(integer.image));
			module.addGlobalVariable(s);
			System.out.println("Its a scalar");
		}
	} ) )? <PVIRG>
}

void Function() #Function: { Token functionID; }
{
	(LOOKAHEAD(3) (<FUNCTION> (LOOKAHEAD(2) ArrayElement() | ScalarElement()) <ASSIGN> functionID=<ID> {
		Function function = new Function(functionID.image);
		module.addFunction(function);
		//System.out.println("Function: " + functionID.image);
	} <LPAR> (Varlist())? <RPAR>) | (<FUNCTION> functionID=<ID> {
		Function function = new Function(functionID.image);
		module.addFunction(function);
		//System.out.println("Function: " + functionID.image);
	} <LPAR> (Varlist())? <RPAR>)) <LCHAVETA> FunctionBody() <RCHAVETA>
}

void Varlist() #Params: {}
{
	(LOOKAHEAD(2) ArrayElement() | ScalarElement()) (<VIRG> (LOOKAHEAD(2) ArrayElement() | ScalarElement()))*
}

String ArrayElement() #StoreArray: { Token arrayElem; }
{
	arrayElem=<ID> "[" "]" { return arrayElem.image; }
}

String ScalarElement() #StoreVariable: { Token scalarElem; }
{
	scalarElem=<ID> { return scalarElem.image; }
}

void FunctionBody() #FunctionBody: {}
{
	(Stmt())*
}

void Stmtlst() #Body: {}
{
	(Stmt())*
}

void Stmt() #void: {}
{
	While() | If() | LOOKAHEAD(3) Assign() | Call() <PVIRG>
}

void Assign() #Assignement: {}
{
	Lhs() <ASSIGN> Rhs() <PVIRG>
}

void Lhs() #void: {}
{
	LOOKAHEAD(2) ArrayAccess() | ScalarAccess()
}

void Rhs() #void: {}
{
	(Term() ((<ARITH_OP> | <BITWISE_OP> | <ADDSUB_OP>) Term())?) | "[" ArraySize() "]"
}

int ArraySize(): {Token size;}
{
	ScalarAccess() | size=<INTEGER> {return Integer.parseInt(size.image);}
}

void Term(): {}
{
	(<ADDSUB_OP>)? (<INTEGER> | LOOKAHEAD(3) Call() | LOOKAHEAD(2) ArrayAccess() | ScalarAccess())
}

void Exprtest() #Condition: {}
{
	<LPAR> Lhs() <RELA_OP> Rhs() <RPAR>
}

void While(): {}
{
	<WHILE> Exprtest() <LCHAVETA> Stmtlst() <RCHAVETA>
}

void If(): {}
{
	<IF> Exprtest() <LCHAVETA> Stmtlst() <RCHAVETA> (<ELSE> <LCHAVETA> Stmtlst() <RCHAVETA>)?
}

void Call(): {}
{
	<ID> ("." <ID>)? <LPAR> (ArgumentList())? <RPAR>
}

void ArgumentList(): {}
{
	Argument() (<VIRG> Argument())*
}

void Argument(): {}
{
	<ID> | <STRING> | <INTEGER>
}

void ArrayAccess(): {}
{
	<ID> "[" Index() "]"
}

void ScalarAccess(): {}
{
	<ID> ("." <SIZE>)?
}

void Index(): {}
{
	<ID> | <INTEGER>
}
